\chapter{Imperative Programmierung (C \& Java)}

Nachfolgend wird je ein Beispiel für ein imperatives (\ref{lst:c-imperativ}), ein strukturiertes (\ref{lst:c-strukturiert}) und ein prozedurales (\ref{lst:c-prozedural}) C-Programm.

\begin{lstlisting}[language=C, caption=Imperatives C-Programm, label=lst:c-imperativ]
int a = 25; 				// Variablen-Deklaration
int b = 15; 				// Variablen-Deklaration
start: 						// Sprungmarke
if (a > b) a = a - b; 		// Auswahl
else b = b - a; 			// Alternative
if (a != b) goto start; 	// Bedingung (goto!!)
printf("result = %i", a); 	// Konsolen-Ausgabe
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Strukturiertes C-Programm, label=lst:c-strukturiert]
int a = 25; 				// Variablen-Deklaration
int b = 15; 				// Variablen-Deklaration
while (a != b) { 			// Schleife
	if (a > b) a = a - b; 	// Auswahl
	else b = b - a; 		// Alternative
}
printf("result = %i", a); 	// Konsolen-Ausgabe
\end{lstlisting}

\begin{lstlisting}[language=C, caption=Prozedurales C-Programm, label=lst:c-prozedural]
int main() { 						// Hauptfunktion
	int result = gcd(25, 15); 		// Funktionsaufruf
	printf("result = %i", result); 	// Konsolen-Ausgabe
	return 0; 						// Funktionsrückgabe
}
int gcd(int a, int b) { 			// Funktionskopf
	while (a != b) { 				// Schleife
		if (a > b) a = a - b; 		// Auswahl
		else b = b - a; 			// Alternative
	}
	return a; 						// Funktionsrückgabe
}
\end{lstlisting}

C kennt nicht nur elementare Datentypen (\verb|int, char, Array[]| usw.), sondern auch zusammengesetzte Datentypen (z.B. Kunde, Stack usw.). In C können zusammengesetzte Datentypen und Datenstrukturen mit Hilfe von Strukturen (\verb|struct|) und einer Typdefinition (\verb|typedef|) erzeugt werden. Strukturen fassen eine Liste von Variablen zusammen. Strukturen werden in C als Werte (\textit{call by value}) an Funktionen übergeben. Möchte man Strukturen als Referenz übergeben, muss man Zeiger und Pointer verwenden. Listing \ref{lst:struct} zeigt die Definition und Anwendung einer Struktur.

\begin{lstlisting}[language=C, caption=Strukturen, label=lst:struct]
// Definition
struct point {
	int x;
	int y;
};

// Anwendung
struct point p; p.x = 100; p.y = 200;
printf(" p = (%i, %i)", p.x, p.y);
\end{lstlisting}

Mit dem Schlüsselwort \verb|typedef| lassen sich eigene Datentypen definieren. Diese werden oft verwendet, da jedes System die Datentypen auf seine Art und Weise interpretieren kann. Auf gewissen Systemen ist ein \verb|int| 64Bit und auf anderen nur 32Bit. Mit eigenen Datentypen lässt sich die Länge fix definieren. Listing \ref{lst:typedef} zeigt ein Beispiel für eigene Datentypen.

\begin{lstlisting}[language=C, caption=Eigene Typen, label=lst:typedef]
typedef int people_count; // create own data type
people_count attendees = 55; // use own data type
\end{lstlisting}

Wenn man eine Struktur mit einem eigenen Datentyp kombiniert, kann man das Schlüsselwort \verb|struct| bei der Deklaration einer Struktur weglassen. Listing \ref{lst:struct-typedef} zeigt ein Anwendungsbeispiel.

\begin{lstlisting}[language=C, caption=Struktur als eigener Datentypen, label=lst:struct-typedef]
typedef struct {
	int x;
	int y;
} point_type;
point_type pt; // Hier kommt kein struct mehr
pt.x = 100; pt.y = 200;
\end{lstlisting}

In C werden abstrakte Datentypen (ADT) verwendet, um Daten und Operationen miteinander zu verwenden. Ein ADT beschreibt, was die Operationen tun (Semantik), aber noch nicht, wie sie es tun sollen (Implementierung). Ein typisches Beispiel für ein ADT ist ein Stack. Listing \ref{lst:stack} zeigt den ADT eines Stacks, welcher die Funktionssignatur und die Semantik definiert.

\begin{lstlisting}[language=C, caption=ADT Stack, label=lst:stack]
// Signatur der Stack-Operationen z.B. im *.h
stack init(); 					// returns new empty stack
stack push(element e, stack s); // adds element to stack
element top(stack s); 			// returns top element
stack pop(stack s); 			// removes top element
void print(stack s); 			// prints all elements
// Semantik ist aber unabhängig von der Implementierung
top(init()) = ERROR
top(push(e, init()) = e
pop(init()) = init()
pop(push(e, s)) = s
\end{lstlisting}

ADT bietet zwar Datenstrukturen und darauf definierte Operationen, allerdings ist die Implementierung der Datenstruktur getrennt von der Implementierung der dazu gehörigen Funktionen. Objektorientierte Programmierung löst dieses Problem, indem sie die Daten und Operationen zusammenbringt (Klassen haben Zustand und Verhalten). OO ist in diesem Sinn eine Weiterentwicklung von ADTs. Java erweitert C also im wesentlichen um folgende
Konzepte (und Schlüsselwörter):

\begin{itemize}
	\item Klassen + Instanzen: \verb|class, extends, instanceof, new, this, super|
	\item Interfaces: \verb|interface, implements|
	\item Packages: \verb|package, import|
	\item Sichtbarkeit: \verb|private, protected, public|
	\item Exception-Handling: \verb|try, catch, finally, throw(s)|
\end{itemize}